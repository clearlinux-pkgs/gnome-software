From 26f8ede429ecd85f0217818f314c464d72b93316 Mon Sep 17 00:00:00 2001
From: Josue David Hernandez Gutierrez <josue.d.hernandez.gutierrez@intel.com>
Date: Wed, 9 Jan 2019 21:36:27 -0600
Subject: [PATCH] [WIP] Integrating swupd to gnome-software

print bundles in bundle category, research how to add custom desktop groups (app categories)
install hook working.
remove hook working.
search work for bundle name.
real description is available.
custom icons are now available.
rate and comments are now disabled.
avoid conflicts using the bundle name as identifier with a custom prefix.
bundles are listed in the PackageManager Category in order.
there is a subcategory to separate dev bundle and bundles.
there is a new cache created to load and search faster.
separate devpack bundles in a sub category.
add package bundles in the lists.
installed section show now the installed bundles.
now the installation of a bundle can be cancelled.

TODO:
- show just bundles in the bundle category.
- remove sudo for install, remove and cancell install.

Signed-off-by: Josue David Hernandez Gutierrez <josue.d.hernandez.gutierrez@intel.com>

Signed-off-by: Patrick McCarty <patrick.mccarty@intel.com>

Signed-off-by: Auke Kok <auke-jan.h.kok@intel.com>
---
 meson_options.txt               |   1 +
 plugins/meson.build             |   3 +
 plugins/swupd/gs-plugin-swupd.c | 506 ++++++++++++++++++++++++++++++++
 plugins/swupd/meson.build       |  16 +
 4 files changed, 526 insertions(+)
 create mode 100644 plugins/swupd/gs-plugin-swupd.c
 create mode 100644 plugins/swupd/meson.build

diff --git a/meson_options.txt b/meson_options.txt
index e19656fb..f766a0d4 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -7,6 +7,7 @@ option('packagekit_autoremove', type : 'boolean', value : false, description : '
 option('polkit', type : 'boolean', value : true, description : 'enable PolKit support')
 option('fwupd', type : 'boolean', value : true, description : 'enable fwupd support')
 option('flatpak', type : 'boolean', value : true, description : 'enable Flatpak support')
+option('swupd', type : 'boolean', value : true, description : 'enable Swupd support')
 option('rpm_ostree', type : 'boolean', value : false, description : 'enable rpm-ostree support')
 option('steam', type : 'boolean', value : true, description : 'enable Steam support')
 option('shell_extensions', type : 'boolean', value : true, description : 'enable shell extensions support')
diff --git a/plugins/meson.build b/plugins/meson.build
index 528743d3..d6df4b8a 100644
--- a/plugins/meson.build
+++ b/plugins/meson.build
@@ -13,6 +13,9 @@ subdir('dummy')
 subdir('epiphany')
 subdir('fedora-pkgdb-collections')
 
+if get_option('swupd')
+  subdir('swupd')
+endif
 if get_option('flatpak')
   subdir('flatpak')
 endif
diff --git a/plugins/swupd/gs-plugin-swupd.c b/plugins/swupd/gs-plugin-swupd.c
new file mode 100644
index 00000000..1bd17df6
--- /dev/null
+++ b/plugins/swupd/gs-plugin-swupd.c
@@ -0,0 +1,506 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//#include <config.h>
+
+#include <gnome-software.h>
+#include <glib/gstdio.h>
+
+#define GS_PLUGIN_SWUPD_CATEGORY "PackageManager"
+
+#define GS_PLUGIN_SWUPD_BUNDLES_URL "https://clearlinux.org/documentation/clear-linux/concepts/bundles-about"
+
+// FileSystem
+#define GS_PLUGIN_SWUPD_VERSION_FILE "/usr/share/clear/version"
+#define GS_PLUGIN_SWUPD_BUNDLES_PATH "/usr/share/clr-bundles"
+#define GS_PLUGIN_SWUPD_BUNDLES_INSTALLED_PATH "/usr/share/clear/bundles"
+#define GS_PLUGIN_SWUPD_BUNDLES_ICON_PATH "/usr/share/clear/bundle-icons"
+#define GS_PLUGIN_SWUPD_BUNDLES_DEFAULT_ICON_PATH GS_PLUGIN_SWUPD_BUNDLES_ICON_PATH"/bundle.svg"
+
+struct GsPluginData {
+	GPtrArray *bundles;
+	gchar *clr_version;
+};
+
+
+gchar *
+gs_plugin_swupd_get_app_desc (const gchar *bundle_name)
+{
+	g_autofree gchar *file_path = g_strdup_printf ("%s/%s",
+						       GS_PLUGIN_SWUPD_BUNDLES_PATH,
+						       bundle_name);
+	g_autofree gchar *file_content = NULL;
+	g_autofree gchar **file_lines = NULL;
+	gchar *desc = NULL;
+	guint i;
+
+	if (!g_file_get_contents (file_path,
+				  &file_content,
+				  NULL,
+				  NULL))
+		g_error ("Error reading from %s", file_path);
+
+	file_lines = g_strsplit (file_content, "\n", 5);
+	for (i = 0; file_lines[i] != NULL; i++) {
+		gchar *tmp_str = g_strrstr (file_lines[i], "# [DESCRIPTION]: ");
+		if (tmp_str != NULL) {
+			g_autofree gchar **tmp_list = g_strsplit (tmp_str, ":", 2);
+			desc = g_strdup (tmp_list[1]);
+			break;
+		}
+	}
+	return desc;
+}
+
+static gboolean
+gs_plugin_swupd_is_installed (gchar *bundle_name)
+{
+	gchar *file_path = g_strdup_printf ("/usr/share/clear/bundles/%s", bundle_name);
+	gboolean ret = g_file_test (file_path, G_FILE_TEST_EXISTS);
+	g_free (file_path);
+	return ret;
+}
+
+GsApp *
+gs_plugin_swupd_get_app (GsPlugin *plugin,
+			 const gchar *bundle_name,
+			 const gchar *desc)
+{
+	gchar *icon_path = NULL;
+	g_autofree gchar *bundleid = NULL;
+	GsApp *app = NULL;
+
+	bundleid = g_strconcat ("org.clearlinux.", bundle_name, NULL);
+	app = gs_plugin_cache_lookup (plugin, bundleid);
+	if (app == NULL) {
+		app = gs_app_new (bundleid);
+		icon_path = g_strdup_printf ("%s/%s.svg",
+					     GS_PLUGIN_SWUPD_BUNDLES_ICON_PATH,
+					     bundle_name);
+		if (!g_file_test (icon_path, G_FILE_TEST_EXISTS)) {
+			g_free (icon_path);
+			icon_path = g_strdup_printf ("%/%.png",
+						     GS_PLUGIN_SWUPD_BUNDLES_ICON_PATH,
+						     bundle_name);
+		}
+		if (!g_file_test (icon_path, G_FILE_TEST_EXISTS)) {
+			g_free (icon_path);
+			icon_path = GS_PLUGIN_SWUPD_BUNDLES_DEFAULT_ICON_PATH;
+		}
+		gs_app_set_pixbuf (app, gdk_pixbuf_new_from_file (icon_path, NULL));
+		gs_app_set_name (app, GS_APP_QUALITY_NORMAL, bundle_name);
+		gs_app_set_url (app, AS_URL_KIND_HOMEPAGE, GS_PLUGIN_SWUPD_BUNDLES_URL);
+		gs_app_set_kind (app, AS_APP_KIND_DESKTOP);
+		gs_app_add_quirk (app, AS_APP_QUIRK_NOT_LAUNCHABLE);
+		gs_app_add_quirk (app, AS_APP_QUIRK_NOT_REVIEWABLE);
+		gs_app_add_quirk (app, AS_APP_QUIRK_PROVENANCE);
+
+		// check for app state
+		if (gs_plugin_swupd_is_installed (bundle_name))
+			gs_app_set_state (app, AS_APP_STATE_INSTALLED);
+		else
+			gs_app_set_state (app, AS_APP_STATE_AVAILABLE);
+
+		gs_app_add_category (app, GS_PLUGIN_SWUPD_CATEGORY);
+		gs_app_set_summary (app, GS_APP_QUALITY_NORMAL, desc);
+		gs_app_set_description (app, GS_APP_QUALITY_NORMAL, desc);
+		gs_app_set_management_plugin (app, gs_plugin_get_name (plugin));
+		gs_plugin_cache_add (plugin, bundleid, app);
+	}
+	return app;
+}
+
+gboolean
+gs_plugin_swupd_equal (gconstpointer a, gconstpointer b)
+{
+	return g_strcmp0 (gs_app_get_name ((GsApp*)a), (gchar *)b) == 0;
+}
+
+void
+gs_plugin_swupd_get_package_bundles (GsPlugin *plugin, GPtrArray *bundles)
+{
+	g_autofree gchar *file_path = g_strdup_printf ("%s/packages",
+						       GS_PLUGIN_SWUPD_BUNDLES_PATH);
+	g_autofree gchar *pname = NULL;
+	g_autofree gchar *file_content = NULL;
+	g_autofree gchar **file_lines = NULL;
+	guint i;
+	GsApp *app = NULL;
+
+	if (!g_file_get_contents (file_path,
+				  &file_content,
+				  NULL,
+				  NULL))
+		g_error ("Error reading from %s", file_path);
+	file_lines = g_strsplit (file_content, "\n", 0);
+	for (i = 0; file_lines[i] != NULL; i++) {
+		if (g_str_has_prefix (file_lines[i], "#"))
+			continue;
+
+		g_autofree gchar **tmp_list = g_strsplit (file_lines[i], " # ", 2);
+
+		app = gs_plugin_swupd_get_app (plugin, tmp_list[0], tmp_list[1]);
+		gs_app_set_metadata (app, "ClearLinux::bundle-type", "package");
+		g_ptr_array_add (bundles, app);
+	}
+}
+
+gchar *
+gs_plugin_swupd_get_clrversion (void)
+{
+	gchar *version = NULL;
+	GError *error = NULL;
+	if (!g_file_get_contents (GS_PLUGIN_SWUPD_VERSION_FILE, &version, NULL, &error)) {
+		g_error ("error reading from %s", GS_PLUGIN_SWUPD_VERSION_FILE);
+	}
+	return version;
+}
+
+void
+gs_plugin_swupd_get_apps (GsPlugin *plugin, GPtrArray *bundles)
+{
+	g_autofree gchar *fname = NULL;
+	GString *id = NULL;
+
+	g_autoptr(GDir) *bundles_dir = NULL;
+
+	bundles_dir = g_dir_open (GS_PLUGIN_SWUPD_BUNDLES_PATH, 0, NULL);
+	while ((fname = g_dir_read_name (bundles_dir)) != NULL) {
+		GsApp *app = NULL;
+		if (g_strcmp0 (fname, "packages") == 0)
+			continue;
+
+		app = gs_plugin_swupd_get_app (plugin, fname,
+					       gs_plugin_swupd_get_app_desc (fname));
+		gs_app_set_metadata (app, "ClearLinux::bundle-type", "bundle");
+		g_ptr_array_add (bundles, app);
+	}
+
+	// adding package bundles
+	gs_plugin_swupd_get_package_bundles (plugin, bundles);
+}
+
+void
+gs_plugin_initialize (GsPlugin *plugin)
+{
+	GsPluginData *priv = gs_plugin_alloc_data (plugin, sizeof (GsPluginData));
+
+	// need categories
+	gs_plugin_add_rule (plugin, GS_PLUGIN_RULE_RUN_AFTER, "desktop-categories");
+	priv->clr_version = gs_plugin_swupd_get_clrversion ();
+
+	priv->bundles = g_ptr_array_new_with_free_func ((GDestroyNotify) g_object_unref);
+	gs_plugin_swupd_get_apps (plugin, priv->bundles);
+}
+
+void
+gs_plugin_destroy (GsPlugin *plugin)
+{
+	GsPluginData *priv = gs_plugin_get_data (plugin);
+	g_ptr_array_unref (priv->bundles);
+	g_free (priv->clr_version);
+}
+
+gboolean
+gs_plugin_add_categories (GsPlugin *plugin,
+			  GPtrArray *list,
+			  GCancellable *cancellable,
+			  GError **error)
+{
+	g_autoptr(GsCategory) sub1 = NULL;
+	g_autoptr(GsCategory) sub2 = NULL;
+
+	GsCategory *bundles = gs_category_new ("clr-bundles");
+	gs_category_set_name(bundles, "Bundles");
+	gs_category_set_score (bundles,85);
+	gs_category_add_key_color (bundles, "#FF0000");
+	gs_category_set_icon (bundles, "text-editor-symbolic");
+	g_ptr_array_add (list, bundles);
+
+	sub1 = gs_category_new ("all");
+	gs_category_add_desktop_group (sub1, GS_PLUGIN_SWUPD_CATEGORY);
+	gs_category_set_name (sub1, "All");
+	gs_category_add_child (bundles, sub1);
+
+	sub2 = gs_category_new ("dev");
+	gs_category_add_desktop_group (sub2, GS_PLUGIN_SWUPD_CATEGORY);
+	gs_category_set_name (sub2, "Devbundles");
+	gs_category_add_child (bundles, sub2);
+
+	return TRUE;
+}
+
+gboolean
+gs_plugin_add_category_apps (GsPlugin *plugin,
+			     GsCategory *category,
+			     GsAppList *list,
+			     GCancellable *cancellable,
+			     GError **error)
+{
+	GsPluginData *priv = gs_plugin_get_data (plugin);
+	guint i = 0;
+	GsCategory *c;
+	g_autoptr(GString) id = NULL;
+
+	id = g_string_new ("");
+	for (c = category; c != NULL; c = gs_category_get_parent (c)) {
+		if (c != category)
+			g_string_prepend (id, "/");
+		g_string_prepend (id, gs_category_get_id (c));
+	}
+
+	if (!g_str_has_prefix (id->str, "clr-bundles/"))
+		return TRUE;
+
+	for (i = 0; i < priv->bundles->len; i++) {
+		GsApp *tmp = g_ptr_array_index (priv->bundles, i);
+
+		if (g_strcmp0 (gs_category_get_id (category), "dev") == 0) {
+			if (g_str_has_prefix (gs_app_get_name (tmp), "devpkg-"))
+				gs_app_list_add (list, tmp);
+		} else
+			gs_app_list_add (list, tmp);
+	}
+	return TRUE;
+}
+
+
+static gboolean
+swup_install_watcher (GIOChannel   *channel,
+             GIOCondition  cond,
+             gpointer user_data )
+{
+	gchar *str = NULL;
+	gsize size;
+	guint progress = 0;
+	GsApp *app = (GsApp *)user_data;
+
+	if(cond == G_IO_HUP) {
+		g_io_channel_unref( channel );
+		return FALSE;
+	}
+
+	progress = gs_app_get_progress (app);
+
+	g_io_channel_read_line( channel, &str, &size, NULL, NULL );
+	if (strstr (str, "Downloading packs") != NULL)
+		progress = 20;
+	if (strstr (str, "Starting download of remaining update content") != NULL)
+		progress = 40;
+	if (strstr (str, "Finishing download of update content") != NULL)
+		progress = 60;
+	if (strstr (str, "Installing bundle(s) files") != NULL)
+		progress = 80;
+	if (strstr (str, "Successfully installed") != NULL)
+		progress = 100;
+
+	g_debug("output : \n:%s\n", str);
+	gs_app_set_progress (app, progress);
+
+	g_free( str );
+	return TRUE;
+}
+
+static void
+gs_plugin_swupd_cancel_cb (GCancellable *cancellable, gpointer user_data)
+{
+	g_autofree gchar *cmd = NULL;
+	g_debug ("canceling process");
+	/* TODO: remove sudo and use the pid in user_data to kill swupd */
+	cmd = g_strdup_printf ("sudo pkill -9 swupd");
+	g_spawn_command_line_async (cmd, NULL);
+}
+
+gboolean
+gs_plugin_app_install (GsPlugin *plugin,
+                       GsApp *app,
+                       GCancellable *cancellable,
+                       GError **error)
+{
+	/* only process this app if was created by this plugin */
+	if (g_strcmp0 (gs_app_get_management_plugin (app),
+		       gs_plugin_get_name (plugin)) != 0)
+		return TRUE;
+
+	g_debug ("Installing bundle %s", gs_app_get_name (app));
+
+	/* TODO: remove sudo using polkit or something like that */
+	gchar *argv[] = {"/usr/bin/sudo", "/usr/bin/swupd", "bundle-add", gs_app_get_name (app), NULL};
+	gint child_stdout, child_stderr;
+	GIOChannel *out_ch, *err_ch;
+	GPid child_pid;
+	g_autoptr(GError) err = NULL;
+	int status;
+
+	gs_app_set_state (app, AS_APP_STATE_INSTALLING);
+	g_spawn_async_with_pipes (NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD, NULL,
+				  NULL, &child_pid, NULL, &child_stdout,
+				  &child_stderr, &err);
+	if (err != NULL) {
+		g_error ("Spawning child failed: %s", err->message);
+		return FALSE;
+	}
+
+	out_ch = g_io_channel_unix_new( child_stdout );
+	err_ch = g_io_channel_unix_new( child_stderr );
+
+	g_io_add_watch (out_ch, G_IO_IN | G_IO_HUP, (GIOFunc)swup_install_watcher, (gpointer)app);
+	g_io_add_watch (err_ch, G_IO_IN | G_IO_HUP, (GIOFunc)swup_install_watcher, (gpointer)app);
+
+	//	g_child_watch_add (child_pid, swupd_finished, (gpointer)app);
+
+	g_signal_connect (cancellable, "cancelled", G_CALLBACK (gs_plugin_swupd_cancel_cb), (gpointer)&child_pid);
+
+	wait(&status);
+	if (!status)
+		gs_app_set_state (app, AS_APP_STATE_INSTALLED);
+	else
+		gs_app_set_state (app, AS_APP_STATE_AVAILABLE);
+
+	return gs_app_get_state (app) == AS_APP_STATE_INSTALLED;
+}
+
+gboolean
+gs_plugin_app_remove (GsPlugin *plugin,
+                      GsApp *app,
+                      GCancellable *cancellable,
+                      GError **error)
+{
+	/* only process this app if was created by this plugin */
+	if (g_strcmp0 (gs_app_get_management_plugin (app),
+		       gs_plugin_get_name (plugin)) != 0)
+		return TRUE;
+
+	g_debug ("Removing bundle %s", gs_app_get_name (app));
+
+	/* TODO: remove sudo using polkit */
+	gchar *argv[] = {"/usr/bin/sudo", "/usr/bin/swupd", "bundle-remove", gs_app_get_name (app), NULL};
+	gchar *child_stdout=NULL;
+	gchar *child_stderr=NULL;
+	gint exit_status;
+	GPid child_pid;
+	g_autoptr(GError) error_swupd = NULL;
+
+	gs_app_set_state (app, AS_APP_STATE_REMOVING);
+	g_spawn_sync (NULL, argv, NULL, G_SPAWN_DEFAULT, NULL,
+		      NULL, &child_stdout,
+		      &child_stderr, &exit_status, &error_swupd);
+	g_debug ("swupd output %s", child_stdout);
+	g_debug ("swupd stderr %s", child_stderr);
+	if (error_swupd != NULL) {
+		g_error ("Spawning child failed: %s", error_swupd->message);
+		return FALSE;
+	}
+
+	gs_app_set_state (app, AS_APP_STATE_AVAILABLE);
+	return TRUE;
+}
+
+gboolean
+gs_plugin_swupd_bundles_exists (GsApp *app)
+{
+	gchar *type = gs_app_get_metadata_item (app, "ClearLinux::bundle-type");
+	gchar *bname = gs_app_get_name (app);
+	g_autofree gchar *tmp = NULL;
+
+	if (g_strcmp0 (type, "bundle") == 0) {
+		g_autofree gchar *file_content = NULL;
+		g_autofree gchar *path = g_strdup_printf ("%s/packages",
+							  GS_PLUGIN_SWUPD_BUNDLES_PATH);
+		tmp = g_strdup_printf ("%s #", bname);
+		if (!g_file_get_contents (path, &file_content, NULL, NULL))
+			g_error ("Error reading file %s", path);
+		return g_strrstr (file_content, tmp) != NULL;
+	} else {
+		tmp = g_strdup_printf ("%s/%s",
+				       GS_PLUGIN_SWUPD_BUNDLES_PATH,
+				       bname);
+		return g_file_test (tmp, G_FILE_TEST_EXISTS);
+	}
+}
+
+
+gboolean
+gs_plugin_refresh (GsPlugin *plugin,
+		   guint cache_age,
+		   GCancellable *cancellable,
+		   GError **error)
+{
+	GsPluginData *priv = gs_plugin_get_data (plugin);
+	g_autofree gchar *system_version = gs_plugin_swupd_get_clrversion ();
+	guint i;
+
+	// is there nothing to update?
+	if (g_strcmp0 (priv->clr_version, system_version) == 0)
+		return TRUE;
+
+	// removing deleted bundles
+	for (i = 0; i < priv->bundles->len; i++) {
+		GsApp *app = g_ptr_array_index (priv->bundles, i);
+		if (gs_plugin_swupd_bundles_exists (app))
+			continue;
+			g_ptr_array_remove (priv->bundles, app);
+			gs_plugin_cache_remove (plugin, gs_app_get_id (app));
+	}
+
+	// adding new bundles
+	gs_plugin_swupd_get_apps (plugin, priv->bundles);
+
+	return TRUE;
+}
+
+gboolean
+gs_plugin_add_search (GsPlugin *plugin,
+                      gchar **values,
+                      GsAppList *list,
+                      GCancellable *cancellable,
+                      GError **error)
+{
+	GsPluginData *priv = gs_plugin_get_data (plugin);
+	gint i,j;
+
+	for (i = 0; values[i] != NULL; i++) {
+		for (j = 0; j < priv->bundles->len; j++) {
+			GsApp *tmp = g_ptr_array_index (priv->bundles, j);
+			if (!g_str_has_prefix (gs_app_get_name (tmp), values[i]))
+				continue;
+			gs_app_list_add (list, tmp);
+		}
+	}
+	return TRUE;
+}
+
+gboolean
+gs_plugin_add_installed (GsPlugin *plugin,
+			 GsAppList *list,
+			 GCancellable *cancellable,
+			 GError **error)
+{
+	GsPluginData *priv = gs_plugin_get_data (plugin);
+	guint i;
+
+	for (i = 0; i < priv->bundles->len; i++) {
+		GsApp *app = g_ptr_array_index (priv->bundles, i);
+		if (gs_app_get_state (app) == AS_APP_STATE_INSTALLED) {
+			g_debug ("installed app %s", gs_app_get_name (app));
+			gs_app_list_add (list, g_steal_pointer(&app));
+		}
+	}
+	return TRUE;
+}
diff --git a/plugins/swupd/meson.build b/plugins/swupd/meson.build
new file mode 100644
index 00000000..dfac7d7d
--- /dev/null
+++ b/plugins/swupd/meson.build
@@ -0,0 +1,16 @@
+cargs = ['-DG_LOG_DOMAIN="GsPluginSwupd"']
+cargs += ['-DLOCALPLUGINDIR="' + meson.current_build_dir() + '"']
+cargs += ['-DLOCALPLUGINDIR_CORE="' + meson.current_build_dir() + '/../core"']
+
+shared_module(
+  'gs_plugin_swupd',
+  sources : 'gs-plugin-swupd.c',
+  include_directories : [
+    include_directories('../..'),
+    include_directories('../../lib'),
+  ],
+  install : true,
+  install_dir: plugin_dir,
+  c_args : cargs,
+  dependencies : [appstream_glib, gio_unix, gtk, libsoup]
+)
-- 
2.20.1

